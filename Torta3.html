<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Torta - Prender vela</title>
  <style>
    :root{
      --bg:#111;
      --card:#fff;
      --accent:#ff6b00;
      --text:#111;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#f8f7f2, #fff);display:flex;align-items:center;justify-content:center}

    .app{width:100%;max-width:540px;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;box-sizing:border-box}

    .scene{position:relative;width:100%;display:flex;align-items:center;justify-content:center}
    /* Maintain square image responsive */
    .cake-wrap{width:100%;max-width:420px;position:relative}
    .cake-wrap .cake{width:100%;height:auto;display:block;border-radius:18px;box-shadow:0 8px 24px rgba(0,0,0,.12)}

    /* Flame will be positioned absolutely relative to cake-wrap */
    .flame{position:absolute;left:53%;top:14%;transform:translate(-50%,-100%);pointer-events:none;display:none;width:6.5%;min-width:28px;max-width:90px}

    /* Simple CSS flame: the container holds two layers for flicker */
    .flame .f{position:relative;width:100%;padding-top:170%;border-radius:50% 50% 35% 35%/60% 60% 40% 40%;transform-origin:center bottom}
    .flame .f::before{content:'';position:absolute;left:50%;top:18%;transform:translateX(-50%);width:52%;height:72%;border-radius:50% 50% 35% 35%/60% 60% 40% 40%;background: radial-gradient(ellipse at 50% 30%, rgba(255,250,180,1) 0%, rgba(255,170,50,1) 45%, rgba(255,80,20,1) 80%);filter:drop-shadow(0 6px 8px rgba(255,140,40,.15))}
    .flame .f::after{content:'';position:absolute;left:50%;top:34%;transform:translateX(-50%);width:30%;height:40%;border-radius:50%;background:radial-gradient(circle at 40% 30%, rgba(255,255,210,1), rgba(255,200,100,0.9));opacity:.95}

    /* flicker animation */
    @keyframes flickerS{0%{transform:translateY(0) scale(1)}25%{transform:translateY(-2%) scale(.98)}50%{transform:translateY(0) scale(1.02)}75%{transform:translateY(-1%) scale(.99)}100%{transform:translateY(0) scale(1)}}
    .flame .f{animation: flickerS 160ms infinite alternate}

    /* button */
    .controls{width:100%;display:flex;justify-content:center;margin-top:14px}
    button.big{appearance:none;border:0;background:var(--accent);color:white;padding:14px 20px;border-radius:12px;font-size:5.6vw;min-font-size:18px;font-weight:700;max-width:420px;width:90%;max-font-size:22px;box-shadow:0 8px 18px rgba(0,0,0,.12)}
    /* responsive large text using clamp */
    button.big{font-size:clamp(18px,5.6vw,26px);padding:clamp(12px,3.2vw,18px)}

    /* overlay message */
    .overlay{position:fixed;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .message{pointer-events:auto;background:rgba(0,0,0,.6);color:white;padding:20px 28px;border-radius:14px;font-size:clamp(20px,5.6vw,36px);text-align:center;backdrop-filter:blur(6px);}

    /* hidden meter for debug (optional) */
    #meter{position:fixed;left:8px;bottom:8px;background:rgba(255,255,255,.92);padding:6px 8px;border-radius:8px;font-size:12px;display:none}

    /* ensure portrait friendly */
    @media (orientation:landscape){.app{max-width:760px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="scene">
      <div class="cake-wrap" id="cakeWrap">
        <!-- user should put torta.jpg in same folder -->
        <img src="torta.jpg" alt="Torta" class="cake" id="cakeImg" />

        <!-- flame element - hidden until started -->
        <div class="flame" id="flame" aria-hidden="true">
          <div class="f"></div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="btnToggle" class="big">Prender vela</button>
    </div>

    <!-- overlay message area -->
    <div class="overlay" id="overlay" style="display:none">
      <div class="message" id="overlayMsg">ped√≠ un deseo y sopla la velita</div>
    </div>

    <!-- audio elements (must be in same folder) -->
    <audio id="song" src="cancion.mp3" preload="auto" playsinline></audio>
    <audio id="applause" src="aplausos.mp3" preload="auto" playsinline></audio>

    <div id="meter">--</div>
  </div>

<script>
/* Single-file app behavior:
 - On "Prender vela" click: show flame, start cancion.mp3, enable microphone detection
 - When cancion.mp3 ends: show overlay message asking to blow; keep flame lit
 - If user blows (detect via mic): if song is playing, stop song and play applause (overlay not shown)
   else (if overlay is showing), remove flame, play applause and hide overlay
 - After applause ends, reset to initial state
 - Support multiple cycles
*/

const btn = document.getElementById('btnToggle');
const flame = document.getElementById('flame');
const song = document.getElementById('song');
const applause = document.getElementById('applause');
const overlay = document.getElementById('overlay');
const overlayMsg = document.getElementById('overlayMsg');
const meter = document.getElementById('meter');

let audioCtx=null, analyser=null, micStream=null, dataArray=null, rafId=null;
let isLit = false;
let waitingForBlow = false;
let songPlaying = false;
let blownDuringSong = false;

// thresholds and timing for blow detection. You can tweak these if needed.
const BLOW_RMS_THRESHOLD = 0.06; // higher = requires louder blow
const BLOW_MIN_MS = 120; // must exceed threshold for this many ms

let blowTickStart = null;

// Request microphone permission and create analyser. Must be called on a user gesture.
async function initMic(){
  if(audioCtx) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    micStream = stream;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    source.connect(analyser);
    dataArray = new Float32Array(analyser.fftSize);
    // unhide meter for debug if you want
    // meter.style.display='block';
  }catch(e){
    console.warn('No microphone or permission denied', e);
  }
}

function startMonitoring(){
  if(!analyser) return;
  cancelAnimationFrame(rafId);
  function loop(){
    analyser.getFloatTimeDomainData(dataArray);
    // compute RMS
    let sum = 0;
    for(let i=0;i<dataArray.length;i++){ const v=dataArray[i]; sum += v*v; }
    const rms = Math.sqrt(sum/dataArray.length);
    // update debug meter
    meter.textContent = 'RMS: '+rms.toFixed(4);

    const now = performance.now();
    if(rms > BLOW_RMS_THRESHOLD){
      if(!blowTickStart) blowTickStart = now;
      else{
        if(now - blowTickStart > BLOW_MIN_MS){
          // blow detected
          handleBlowDetected();
          blowTickStart = null;
        }
      }
    }else{
      blowTickStart = null;
    }

    rafId = requestAnimationFrame(loop);
  }
  rafId = requestAnimationFrame(loop);
}

function stopMonitoring(){
  cancelAnimationFrame(rafId);
}

async function handleBlowDetected(){
  // prevent multiple triggers
  if(!isLit) return;

  if(songPlaying){
    // If blow happens while song playing: stop song and play applause. overlay should NOT appear.
    blownDuringSong = true;
    song.pause();
    song.currentTime = 0;
    songPlaying = false;
    waitingForBlow = false;
    hideOverlay();
    extinguishAndApplaud();
  }else if(waitingForBlow){
    // Normal flow: user blows after prompt
    waitingForBlow = false;
    hideOverlay();
    extinguishAndApplaud();
  }
}

function extinguishAndApplaud(){
  // remove flame
  flame.style.display='none';
  isLit = false;
  // stop monitoring mic for a moment
  stopMonitoring();

  // play applause
  playAudio(applause).then(()=>{
    // after applause ends, reset to standby
    resetToStandby();
  });
}

function showOverlay(){ overlay.style.display='flex'; }
function hideOverlay(){ overlay.style.display='none'; }

function resetToStandby(){
  // stop any audio
  try{ song.pause(); song.currentTime=0; }catch(e){}
  try{ applause.pause(); applause.currentTime=0; }catch(e){}
  waitingForBlow=false; songPlaying=false; blownDuringSong=false; isLit=false;
  flame.style.display='none';
  hideOverlay();
  // keep mic open so user can restart without prompt (optional)
}

async function playAudio(el){
  // returns a promise that resolves when audio ends
  return new Promise((res,rej)=>{
    function onend(){ el.removeEventListener('ended',onend); el.removeEventListener('error',onerr); res(); }
    function onerr(e){ el.removeEventListener('ended',onend); el.removeEventListener('error',onerr); res(); }
    el.addEventListener('ended', onend);
    el.addEventListener('error', onerr);
    // ensure starts from beginning
    el.currentTime = 0;
    const p = el.play();
    if(p && p.catch){
      p.catch((e)=>{
        console.warn('Playback failed', e); // e.g. not allowed
        res();
      });
    }
  });
}

// Main button handler
btn.addEventListener('click', async ()=>{
  // If already lit and waiting for blow, do nothing
  if(isLit) return;

  // Ensure mic ready (user gesture)
  await initMic();
  startMonitoring();

  // Light the flame
  flame.style.display='block';
  isLit = true;
  blownDuringSong = false;

  // Play song
  songPlaying = true;
  // ensure overlay hidden
  hideOverlay();

  // play and wait for end (unless interrupted by blow)
  const playPromise = song.play();
  if(playPromise && playPromise.catch){
    playPromise.catch((e)=>{
      // could fail on some restrictive browsers; still treat as ended
      console.warn('playback error', e);
    });
  }

  // Listen for natural end
  function onSongEnd(){
    songPlaying = false;
    song.removeEventListener('ended', onSongEnd);
    if(!blownDuringSong){
      // show overlay prompt to blow
      waitingForBlow = true;
      showOverlay();
      // continue monitoring until blow detected
    }
  }
  song.addEventListener('ended', onSongEnd);
});

// When applause ends (in case something else triggered it), ensure reset handled above via playAudio promise.

// Cleanup when page unloads
window.addEventListener('pagehide', ()=>{
  try{ if(micStream){ micStream.getTracks().forEach(t=>t.stop()); } }catch(e){}
  if(audioCtx){ try{ audioCtx.close(); }catch(e){} }
});

// Accessibility: let ENTER key activate button
btn.addEventListener('keydown', (e)=>{ if(e.key==='Enter') btn.click(); });

// Try to keep flame positioned proportionally if the image size changes.
function updateFlamePosition(){
  // The flame is centered horizontally at about 50% and vertically at 38% of the cake-wrap.
  // If you want to tweak, change the top/left in CSS or compute here.
}
window.addEventListener('resize', updateFlamePosition);
updateFlamePosition();

</script>
</body>
</html>
